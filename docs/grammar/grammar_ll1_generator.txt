%token tVoid tInt tDouble tBool tString tClass tInterface tNull tThis tExtends tImplements tFor tWhile tIf tElse tReturn tBreak tNew tNewArray tPrint tReadInteger tReadLine tId tPlus tMinus tMulti tDiv tMod tLess tLessEqual tGreater tGreaterEqual tEqual tDiff tAssignment tAnd tOr tNot tSemiColon tComma tDot tBracketLeft tBracketRight tParLeft tParRight tBraceLeft tBraceRight tIntConstant tDoubleConstant tTrue tFalse tClassId tStringConstant
%% /* LL(1) */
Prog  		: Dec Prog1  ;
Prog1		: /*eps*/  ;
Prog1		: Prog  ;
Dec   		: ClassDec  ;
Dec   		: InterDec  ;
Dec   		: Var Dec1  ;
Dec   		: tVoid tId FuncDec  ;
Dec1  		: tSemiColon  ;
Dec1  		: FuncDec  ;
Var   		: Type tId  ;
Type  		: tInt Type1  ;
Type  		: tDouble Type1  ;
Type  		: tBool Type1  ;
Type  		: tString Type1  ;
Type  		: tClassId Type1  ;
Type1 		: /*eps*/  ;
Type1 		: tBracketLeft tBracketRight Type1  ;
FuncDec 	: tParLeft Formals tParRight StmtBlock  ;
Formals		: /*eps*/ ;
Formals		: Formals1  ;
Formals1	: Var Formals2  ;
Formals2	: /*eps*/  ;
Formals2	: tComma Formals1  ;
StmtBlock	: tBraceLeft Var tSemiColon StmtBlock1 Stmt tBraceRight  ;
StmtBlock1	: /*eps*/  ;
StmtBlock1	: Var tSemiColon StmtBlock1  ;
Stmt 		: /*eps*/  ;
Stmt 		: IfStmt Stmt  ;
Stmt 		: WhileStmt Stmt  ;
Stmt 		: ForStmt Stmt  ;
Stmt 		: BreakStmt Stmt  ;
Stmt 		: ReturnStmt Stmt  ;
Stmt 		: PrintStmt Stmt  ;
Stmt 		: StmtBlock Stmt  ;
Stmt 		: tSemiColon Stmt ;
Stmt 		: LValue tAssignment Expr tSemiColon Stmt ;
IfStmt      : tIf tParLeft Expr tParRight Stmt ElseStmt  ;
ElseStmt	: /*eps*/  ;
ElseStmt	: tElse Stmt  ;
WhileStmt 	: tWhile tParLeft Expr tParRight Stmt  ;
ForStmt		: tFor tParLeft Expr1 tSemiColon Expr tSemiColon Expr1 tParRight Stmt  ;
ReturnStmt 	: tReturn Expr1 tSemiColon  ;
BreakStmt	: tBreak tSemiColon  ;
PrintStmt 	: tPrint tParLeft Expr PrintStmt1  ;
PrintStmt1	: tParRight tSemiColon  ;
PrintStmt1	: tComma Expr PrintStmt1  ;
ClassDec 	: tClass tId ClassDec1  ;
ClassDec1	: tExtends tId ClassDec2  ;
ClassDec1	: ClassDec2  ;
ClassDec2	: tImplements tId Implements tBraceLeft Field tBraceRight  ;
ClassDec2	: tBraceLeft Field tBraceRight  ;
Implements 	: /*eps*/  ;
Implements 	: tComma tId Implements  ;
Field		: /*eps*/  ;
Field		: Var Dec1 Field  ;
InterDec 	: tInterface tId tBraceLeft Prototype tBraceRight  ;
Prototype 	: /*eps*/  ;
Prototype 	: Var tParLeft Formals tParRight tSemiColon  ;
Prototype 	: tVoid tId tParLeft Formals tParRight tSemiColon  ;
Expr		: F  ;
F           : G F1 ;
F1 			: /*eps*/ ;
F1 			: tOr G F1 ;
F1 			: tAnd G F1   ;
G           : H G1 ;
G1			: /*eps*/ ;
G1          : tLess H G1  ;
G1          : tLessEqual H G1 ;
G1          : tGreater H G1 ;
G1          : tGreaterEqual H G1 ;
G1          : tEqual H G1 ;
G1          : tDiff H G1 ;
H           : I H1  ;
H1          : /*eps*/  ;
H1          : tPlus I H1  ;
H1          : tMinus I H1  ;
I           : J I1  ;
I1          : /*eps*/  ;
I1          : tMulti J I1  ;
I1          : tDiv J I1  ;
I1          : tMod J I1  ;
J           : tNot J  ;
J           : tMinus J ;
J           : Term    ;
Term        : Constant  ;
Term        : tThis  ;
Term        : tReadInteger tParLeft tParRight  ;
Term        : tReadLine tParLeft tParRight  ;
Term        : tNew tParLeft tId tParRight  ;
Term        : tNewArray tParLeft Expr tComma Type tParRight  ;
Term        : LValue;
Term        : tParLeft Expr tParRight  ;
Expr1		: /*eps*/  ;
Expr1		: LValue tAssignment Expr  ;
Expr1		: F  ;
Expr2 		: /*eps*/  ;
Expr2 		: tComma Expr Actual  ;
LValue 		: tId LValue1  ;
LValue1     : Call  ;
LValue1     : tDot tId LValue1  ;
LValue1     : tBracketLeft Expr tBracketRight LValue1  ;
Call		: /*eps*/ ;
Call		: tParLeft Actual tParRight ;
Actual 		: /*eps*/  ;
Actual 		: Expr Expr2  ;
Constant	: tIntConstant  ;
Constant	: tDoubleConstant  ;
Constant	: tTrue  ;
Constant	: tFalse  ;
Constant	: tStringConstant  ;
Constant	: tNull  ;