<!DOCTYPE html>
<html>

    <head>
        <title>LL(1) Parsing</title>
        <meta charset="utf-8" />

	    <link rel="stylesheet" type="text/css" href="shared.css" media="all" />

        <style type="text/css">
            .wideLi { padding:4px; }
            #grammar, #terminals, #nonTerminals, #nullables, 
            #first, #follow, #numberedGrammar, #table, #source,
            #stack, #actions, #derivation {
                width:600px;
                font-family:"Monaco",monospace; 
                font-size:12pt;
                border:2px solid lightgray;
                border-radius:8px;
                background-color:white;
            }
            #grammar, #terminals, #nonTerminals, #nullables, #first, #follow, #numberedGrammar {
                width:1000px;
            }
            #table {
                width:3100px;
            }
            #source {
                width:1000px;
            }            
            
            #terminals, #nonTerminals, #nullables, #first, #follow,
            #actions, #derivation, #numberedGrammar, #table, #source {
                padding:4px;
            }
            
            /* Why is this necessary?? Without it, title has big gap.
               Moving the div down fixes the problem, 
               but a DIFFERENT div then acquires the problem. Same
               in Safari, Chrome, and Firefox. Weird. */
            #terminals {
                margin-top:-15px;
            }
            
            #example1, #example2, #typeEpsilon, #findAll, 
            #findTerminals, #findNonTerminals, #findNullables,
            #findFirst, #findFollow, 
            #findNumberedGrammar, #findTable,
            #start, #step {
                font-size:12pt; 
                border-radius:15px; 
            }
            #example1, #example2 {
              background-color:#BB6; 
              color:white;
            }
            #findAll, #dummyFindAll {
                background-color:#F8F;
            }
             
            #findTerminals, #findNonTerminals, #findNullables {
                background-color:#AAF;
            }
            #dummyFindAll, #dummyStart, #dummyStep, #dummyEpsilon { 
              border-radius: 15px;
              pointer-events:none; 
            }
            #findFirst, #findFollow {
                background-color:#FC6;
            }
            #findNumberedGrammar, #findTable {
                background-color:#A47;
                color:white;
            }
            #typeEpsilon, #dummyEpsilon {
                background-color:#FF8;
            }
            #dummyEpsilon {
                font-size:12pt;
            }
            #start,#dummyStart {
                background-color:#ACA;
            }
            #step, #dummyStep {
                background-color:#7C7;
            }
            
            .grammar {  
                font-family:"Monaco",monospace; 
                font-size:12pt;
                background-color:#FFF; 
                border:2px solid black; 
                border-radius:10px;            
                padding: 6px; 
                display:inline-block;
            }
            .borderedText{  
                border:2px solid black;
                border-radius:4px; 
                background-color:white; 
                padding-top:2px;
            }
            .placeholderText {
                color:#AAA;
            }
            .nonTermText {
                color:blue;
            }
            .tokenText {
                color:red;
            }
            .actionText {
                color:#F80;
            }
            .ruleNumText {
                color:green;
            }
            .substitutionText {
                color:#F0F;
            }
            table {
                font-family: arial, sans-serif;
                border-collapse: collapse;
                width: 100%;
            }

            td, th {
                border: 1px solid #dddddd;
                text-align: left;
                padding: 8px;
            }

        </style>
    </head>

    <body>
        <!--
        <a class='prev' href='../index.html'>Previous</a>
        <span class='header'>☜ Navigate the Parsing pages ☞</span>
        <a class='next_inactive' href='javascript:void(0)'>Next</a>
        <br />
        <hr />
        -->
        
        <h1>LL(1) Parsing</h1>
        <p>Build a <a href='http://en.wikipedia.org/wiki/LL_parser'>parse table</a> for an <a href='http://en.wikipedia.org/wiki/LL_grammar'>LL(1)</a> grammar and use it to find the <a href='http://en.wikipedia.org/wiki/Context-free_grammar#Derivations_and_syntax_trees'>leftmost derivation</a> of a line of code.</p>
        
        <h2>Brief Explanation</h2>
        <p>A grammar is LL(1) if (roughly) you can unambiguously decide which grammar rule to use from 
        exactly one token of lookahead. Although LL parsers have some <a href='http://en.wikipedia.org/wiki/Left_recursion'>shortcomings</a>,
        they are easier to understand than LR parsers, which have always seemed to me like reaching into your left
        pocket with your right hand: it gives you the right result but is quite contorted.</p>
        
        <p>An LL(1) grammar is well suited to table-based parsing. This page implements all the steps
        in constructing and using such a table.</p>
        
        
        <hr />
        <h2>Try It Yourself</h2>
        
        <p>A simple LL(1) grammar is provided, along with a correct line of code. (You can change the grammar; instructions below.)</p>
        <ol>
            <li class='wideLi'>Click <input type='button' id='dummyFindAll' value='Find All' /> to derive all the required sets and construct the parse table.<br />
                Or, click each button sequentially.</li>
            <li class='wideLi'>Click <input type='button' id='dummyStart' value='Start' /> to initialize the parser.</li>
            <li class='wideLi'>Click <input type='button' id='dummyStep' value='Step' /> repeatedly to parse the source code.</li>
        </ol>
    
        <br /><h3>Table Builder</h3>
            
        <p>
        Grammar
        <input 
            type='button' 
            id='example1'
            value='Example 1' 
            onclick='onExample1()' 
        />        
        <input 
            type='button' 
            id='example2'
            value='Example 2' 
            onclick='onExample2()' 
        />        
<br />
        <textarea id='grammar'>
E -> num
E -> ( E Op E )
Op -> +
Op -> *</textarea>
        <br />
        <input 
            type='button' 
            id='typeEpsilon'
            value='Insert an ε' 
            onclick='onTypeEpsilon()' 
        />        
        <input 
            type='button' 
            id='findAll'
            value='Find All' 
            onclick='onFindAll()' 
        />        
        
        <br /><br />Terminals<br />
        <div id='terminals'><span class='placeholderText'>Terminals will go here</span></div>
        <input 
            type='button' 
            id='findTerminals'
            value='Find Terminals' 
            onclick='onFindTerminals()' 
        />        

        <br /><br />Non-terminals<br />
        <div id='nonTerminals'><span class='placeholderText'>Non-terminals will go here</span></div>
        <input 
            type='button' 
            id='findNonTerminals'
            value='Find Non-Terminals' 
            onclick='onFindNonTerminals()' 
        />        

        <br /><br />Nullables<br />
        <div id='nullables'><span class='placeholderText'>Nullables will go here</span></div>
        <input 
            type='button' 
            id='findNullables'
            value='Find Nullables' 
            onclick='onFindNullables()' 
        />        

        <br /><br />FIRST(<span class='nonTermText'>A</span>) = { <span class='tokenText'>t</span> : (<span class='tokenText'>t</span> ≠ <span class='tokenText'>ε</span> & <span class='nonTermText'>A</span> →* <span class='tokenText'>t</span>β) | (<span class='tokenText'>t</span> = <span class='tokenText'>ε</span> & <span class='nonTermText'>A</span> →* <span class='tokenText'>ε</span>) }<br />
        <div id='first'><span class='placeholderText'>FIRST set will go here</span></div>
        <input 
            type='button' 
            id='findFirst'
            value='Find First' 
            onclick='onFindFirst()' 
        />        

        <br /><br />FOLLOW(<span class='nonTermText'>A</span>) = { <span class='tokenText'>t</span> : (<span class='tokenText'>t</span> ≠ <span class='tokenText'>$</span> & <span class='nonTermText'>S</span> →+ α<span class='nonTermText'>A</span><span class='tokenText'>t</span>β) | (<span class='tokenText'>t</span> = <span class='tokenText'>$</span> & <span class='nonTermText'>S</span> →* α<span class='nonTermText'>A</span>) }<br />
        <div id='follow'><span class='placeholderText'>FOLLOW set will go here</span></div>
        <input 
            type='button' 
            id='findFollow'
            value='Find Follow' 
            onclick='onFindFollow()' 
        />        
        
        <br /><br />Numbered Grammar<br />
        <div id='numberedGrammar'><span class='placeholderText'>Numbered grammar will go here</span></div>
        <input 
            type='button' 
            id='findNumberedGrammar'
            value='Find Numbered Grammar' 
            onclick='onFindNumberedGrammar()' 
        />        

        <br /><br />Table<br />
        <div id='table'><span class='placeholderText'>Table will go here</span></div>
        <input 
            type='button' 
            id='findTable'
            value='Find Table' 
            onclick='onFindTable()' 
        />        

        <br /><br /><h3>Parser</h3>
        
        Source (current <span class='tokenText'>token</span> is <span class='tokenText'>red</span>)<br />
        <div id='source' contenteditable>( num * ( num + num ) )</div>
        <input 
            type='button' 
            id='start'
            value='Start' 
            onclick='onStart()' 
        />        
        <input 
            type='button' 
            id='step'
            value='Step' 
            onclick='onStep()' 
        />       
 
        <br /><br />Actions (<span class='tokenText'>token</span> ; <span class='tokenText'>terminal</span>/<span class='nonTermText'>non-terminal</span> stack ; <span class='actionText'>action</span> <span class='tokenText'>token</span>/<span class='ruleNumText'>rule</span>)<br />
        <div id='actions' ><span class='placeholderText'>Actions will go here</a></div>

        <br />Derivation (<span class='substitutionText'>substitution</span> <span class='ruleNumText'>rule➝</span>)<br />
        <div id='derivation'><span class='placeholderText'>Derivation will go here</a></div>
        <br />
     
        <br /><hr />

	    <h2>Remarks</h2>
	    
	    <p>Example 1 is the grammar that appears when you (re)load this page. Example 2 is the
        left-factored form of the common example grammar</p>
        <blockquote class='grammar'>E ➝ T + E | T<br />
        T ➝ num | num * num | ( E )</blockquote>
        </p>
        
        <p>You can change the grammar as you see fit. Some requirements:</p>
        <ul>
            <li>The start production must be the first line.</li>
            <li>All terminals must be non-alphabetic <em>or</em> start with a lower-case letter.</li>
            <li>All non-terminals must start with an Upper-Case Letter.</li>
            <li>The epsilon character <input type='button' id='dummyEpsilon' value='ε' /> represents an empty production.</li>
            <li>Every production must have <em>only</em> one right-hand result.<br />
                So <span class='borderedText'>&nbsp;<span class='nonTermText'>A</span> ➝ <span class='nonTermText'>B</span> | <span class='tokenText'>c</span>&nbsp;</span> 
                must be rendered with two productions
                <span class='borderedText'>&nbsp;<span class='nonTermText'>A</span> ➝ <span class='nonTermText'>B</span>&nbsp;</span> and <span class='borderedText'>&nbsp;<span class='nonTermText'>A</span> ➝ <span class='tokenText'>c</span>&nbsp;</span></li>
            <li>In the code, all tokens must be separated by whitespace.</li>
        </ul>

        <br /><hr />

        <h2>See Also</h2>

        <h3>iPhone Apps</h3>
        <ul>
            <li><a href='../ana-grabr/index.html'>ana-grabr</a> — Interactive helper for finding anagrams for real words.</li>
            <li><a href='../gear-grafr/index.html'>gear-grafr</a> — Tool for plotting gear ratios for bicycles.</li>
        </ul>
        
        <h3>Web Apps</h3>
        <ul>
            <li><a href='../anagrammer/index.html'>Anagrammer</a> — An application of permutations to real words.</li>
            <li><a href='../chaos/index.html'>The Chaos Pages</a> — A series of pages exploring iterated systems.</li>
            <li><a href='../goldenratio/index.html'>The Golden Ratio Pages</a> — A similar series of pages exploring the famous ratio.</li>
            <li><a href='../gears/index.html'>Gear Ratios</a> — These may not be golden, but they are important for people who ride and work with bicycles.</li>
            <li><a href='../matrices/index.html'>Gaussian Elimination</a> — A Web tool for reducing matrices to row echelon form — and keeping a list of the steps you take.</li>
            <li><a href='../enumeration/index.html'>Enumeration</a> — A Web tool for finding permutations and combinations.</li>
            <li><a href='http://www.youtube.com/watch?v=OMDtp89Xqlw'>Combinatorial Music Theory</a> — A lecture connecting graph theory with musical scales and chords.</li>
            <li><a href='../3d/index.html'>The 3D Pages</a> — My JavaScript implementation of interactive 3D graphics .</li>
            <li><a href='../dsp/index.html'>The DSP Pages</a> — Explaining the Fourier transform in the discrete domains.</li>
            <li><a href='../graphclock/index.html'>Graph Clock</a> — A good example of using JavaScript to make a self-modifying Web page, and a little puzzle about elementary connected graphs.</li>
            <li><a href='../regex/index.html'>Regular Expressions</a> — Sometimes a non-match can hang the system.</li>
            <li><a href='../zboard/index.html'>The Z-Board</a> — A new kind of MIDI controller.</li>
        </ul>
	    
	    <!--
        <br />
        <hr />
        <a class='prev' href='../index.html'>Previous</a>
        <span class='header'>☜ Navigate the Chaos pages ☞</span>
        <a class='next' href='javascript:void(0)'>Next</a>
        -->

        <script type="text/javascript">
            "use strict"
            
            window.onload = function() {
                adjustLength(document.getElementById('grammar'));
            }
            
            function wrapSpan(text, tag) {
                return '<span class="' + tag + '">' + text + '</span>';
            }

            function clearFields() {
                listToInnerHTML (['Terminals will go here'],        'terminals',       'placeholderText');
                listToInnerHTML (['Non-terminals will go here'],    'nonTerminals',    'placeholderText');
                listToInnerHTML (['Nullables will go here'],        'nullables',       'placeholderText');
                listToInnerHTML(['FIRST set will go here'],        'first',           'placeholderText');
                listToInnerHTML(['FOLLOW set will go here'],       'follow',          'placeholderText');
                listToInnerHTML(['Numbered grammar will go here'], 'numberedGrammar', 'placeholderText');
                listToInnerHTML(['Table will go here'],            'table',           'placeholderText');
                listToInnerHTML(['Actions will go here'],          'actions',         'placeholderText');
                listToInnerHTML(['Derivation will go here'],       'derivation',      'placeholderText');
                
            }
            
            //------------------------------------------------------------------

            // User can get into trouble if he or she updates these in haphazard order.
            // Too many cases to take care of! Next function helps out.
            function clearGlobals() {
                gStarted = false;
                gDone = false;
                gTerminals = [];
                gNonTerminals = [];
                gFirst = {};
                gFollow = {};
                gTable = {};
            }

            function somethingIsNotSet() {
                return gTerminals.length == 0 || gNonTerminals.length == 0 ||
                        gFirst.length == 0 || gFollow.length == 0 || gTable.length == 0;
            }

            //------------------------------------------------------------------
            
            function adjustLength(elt) {
                var lineCount = lineCountOf(elt.value);
                elt.rows = lineCount > 0 ? lineCount : 1;
            }
    
            //------------------------------------------------------------------

            function lineCountOf(text) {
                var matches = text.match(/\n/gi);
                if (matches == null) {
                    if (text == '') {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    return 1 + matches.length;
                }
            }

            //------------------------------------------------------------------

            function fieldToLines(elementName) {
                var elt = document.getElementById(elementName);
                return elt.value.trim().split('\n');
            }

            //------------------------------------------------------------------

            function linesToField(lines, elementName) {
                var elt = document.getElementById(elementName);
                elt.value = lines.join('\n');
                adjustLength(elt);
            }

            //------------------------------------------------------------------
            // Safari retrieves innerHTML with <br> even if we send it in
            // with <br />. Need to check this with other browsers!!
    
            function listToInnerHTML(list, elementName, markup) {
                var newList = list.slice(0);
                var elt = document.getElementById(elementName);
                for (var i = 0; i < list.length; i++) {
                    newList[i] = wrapSpan(newList[i], markup);
                }
                elt.innerHTML = newList.join(',');
            }
                        
            //------------------------------------------------------------------

            function innerHTMLToLines(elementName) {
                var elt = document.getElementById(elementName);
                return elt.innerHTML.split('<br>');
            }

            //------------------------------------------------------------------

            function linesToInnerHTML(lines, elementName) {
                var elt = document.getElementById(elementName);
                elt.innerHTML = lines.join('<br />');
            }

            //------------------------------------------------------------------

            function hashOfListsToInnerHTML(hol, elementName) {
                var result = '';
                for (var key in hol) {
                    result += wrapSpan(key, 'nonTermText') + ' : ';
                    var list = hol[key].slice(0);
                    for (var i = 0; i < list.length; i++) {
                        list[i] = wrapSpan(list[i], 'tokenText');
                    }
                    result += list.join(',');
                    result += '<br />';
                }
                
                var elt = document.getElementById(elementName);
                elt.innerHTML = result;
            }
            
            //------------------------------------------------------------------

            var padding = ['', ' ', '  ', '   ', '    ', '     ', '      ', '       ', '        ', '         ', '          ', '           ',  '            ',  '             ',  '              ',  '               ',  '                ',  '                 ',  '                  ',  '                   ',  '                    ',  '                     ',  '                      ',  '                       ',  '                        ',  '                         ',  '                          ',  '                           ',  '                            '];

            function pad(word, width, left) {
                var l = word.length;
                var spacesNeeded = width - l;
                if (spacesNeeded < 0) {
                    spacesNeeded = 0;
                }
                if (left == 'left') {
                    return padding[spacesNeeded] + word;
                } else {        // default case
                    return word + padding[spacesNeeded];
                }
            };

            //------------------------------------------------------------------
            
            function maxTermLength() {
                var result = 0;
                for (var i = 0; i < gTerminals.length; i++) {
                    if (gTerminals[i].length > result) {
                        result = gTerminals[i].length;
                    }
                }
                return result;
            }
            
            function maxNonTermLength() {
                var result = 0;
                for (var i = 0; i < gNonTerminals.length; i++) {
                    if (gNonTerminals[i].length > result) {
                        result = gNonTerminals[i].length;
                    }
                }
                return result;
            }

            //------------------------------------------------------------------

            function tableToInnerHTML(table, elementName) {
                var result = pad('', maxNonTermLength());
                result += ' | ';
                for (var tNum = 0; tNum < gTerminals.length; tNum++) {
                    if (gTerminals[tNum] == 'ε') {
                        continue;
                    }
                    var paddedTerm = pad(gTerminals[tNum], maxTermLength() + 1);
                    result += wrapSpan(paddedTerm, 'tokenText');
                }
                result += '<br />';
                for (var _ = 0; _ < maxTermLength() + 3; _++) {
                    result += '—';
                }
                
                for (var tNum = 0; tNum < gTerminals.length; tNum++) {
                    if (gTerminals[tNum] == 'ε') {
                        continue;
                    }
                    for (var _ = 0; _ < maxTermLength() + 1; _++) {
                        result += '—';
                    }
                }
                result += '<br />';
                
                for (var ntNum = 0; ntNum < gNonTerminals.length; ntNum++) {
                    var nt = gNonTerminals[ntNum];
                    var paddedNt = pad(nt, maxNonTermLength());
                    var tableLine = wrapSpan(pad(nt, maxNonTermLength()), 'nonTermText') +  ' | ';
                    for (var tNum = 0; tNum < gTerminals.length; tNum++) {
                        var t = gTerminals[tNum];
                        if (t == 'ε') {
                            continue;
                        }
                        var tableEntry = pad(table[nt][t].toString(), maxTermLength() + 1);
                        tableLine += wrapSpan(tableEntry, 'ruleNumText');
                    }
                    result += tableLine + '<br />';
                }

                var elt = document.getElementById(elementName)
                elt.innerHTML = result;
            }

            function tableToInnerHTML2(table, elementName) {
                var result = '<table>';
                result += '<tr><th></th>';
                for (var i = 0; i < gTerminals.length; i++)
                    result += '<th>' + gTerminals[i] + '</th>';
                result += '</tr>';
                for (var nomTerminal in table) {
                    result += '<tr>';
                    result += '<th>' + nomTerminal + '</th>';
                    var ll1Production = Object.values(table[nomTerminal]);
                    for (var i = 0; i < ll1Production.length; i++)
                        result += '<td>' + ll1Production[i] + '</td>';
                    result += '</tr>';
                }
                result += '</table>';
                var elt = document.getElementById(elementName)
                elt.innerHTML = result;
                console.log(result);
            }
            //------------------------------------------------------------------

            function addElement(mySet, elt) {
                var elementWasAdded = !(elt in mySet);
                mySet[elt] = true;
                return elementWasAdded;
            }

            //------------------------------------------------------------------

            function arrayUnique(array) {
                var result = [];
                for (var i = 0; i < array.length; i++) {
                    if (result.indexOf(array[i]) == -1) {
                        result.push(array[i]);
                    }
                }
                return result;
            }
           
            //------------------------------------------------------------------

            function addList(myHash, key, list) {
                var existingList = myHash[key];
                if (existingList === undefined) {
                    alert('Could not find key ' + key + ' in addList().')
                    return false;    // So we will terminate.
                }
                var joinedArray = existingList.concat(list);
                var mergedArray = arrayUnique(joinedArray);
                myHash[key] = mergedArray;
                var elementWasAdded = mergedArray.length > existingList.length;
                
                return elementWasAdded;
            }
            
            //------------------------------------------------------------------

            function firstCharIsLowerCase(word) {
                return word[0] == word[0].toLowerCase();
            }

            //------------------------------------------------------------------

            function insertAtCursor(myField, myValue) {
                //IE support
                if (document.selection) {
                    myField.focus();
                    sel = document.selection.createRange();
                    sel.text = myValue;
                }
                //MOZILLA and others
                else if (myField.selectionStart || myField.selectionStart == '0') {
                    var startPos = myField.selectionStart;
                    var endPos = myField.selectionEnd;
                    myField.value = myField.value.substring(0, startPos)
                        + myValue
                        + myField.value.substring(endPos, myField.value.length);
                } else {
                    myField.value += myValue;
                }
            }

            //------------------------------------------------------------------

            function removeEpsilon(list) {
                var result = [];
                for (var i = 0; i < list.length; i++) {
                    if (list[i] != 'ε') {
                        result.push(list[i]);
                    }
                }
                return result;
            }            
            
            //------------------------------------------------------------------

            function onTypeEpsilon() {
                var grammarElt = document.getElementById('grammar');
                insertAtCursor(grammarElt, 'ε');
            }
            
            //------------------------------------------------------------------
    
            function markupWord(eltName, words, wordIndex, markup) {
                var localWords = words.slice(0);
                if (wordIndex < words.length) {
                    localWords[wordIndex] = wrapSpan(localWords[wordIndex], markup);
                }
                var elt = document.getElementById(eltName);
                elt.innerHTML = localWords.join(' ');
            }
            
            //------------------------------------------------------------------

            function stripTags(htmlText) {
                var div = document.createElement('div');
                div.innerHTML = htmlText;
                return div.textContent || div.innerText || '';
            }

            //==================================================================

            function onExample1() {
                var grammar = ['E -> num','E -> ( E Op E )','Op -> +','Op -> *'];
                clearFields();
                clearGlobals();
                linesToField(grammar, 'grammar');
                listToInnerHTML(['( num * ( num + num ) )'], 'source');
            }


            function onExample2() {
                var grammar = [
                    'E -> T Add',
                    'Add -> + E',
                    'Add -> ε',
                    'T -> num Mul',
                    'Mul -> * T',
                    'Mul -> ε',
                    'T -> ( E )'
                ];
                clearFields();
                linesToField(grammar, 'grammar');
                listToInnerHTML(['num + num * num'], 'source');            
                clearGlobals();
            }

            //------------------------------------------------------------------

            var gTerminals = [];

            function onFindTerminals() {
                var terminals = {};
                var productions = fieldToLines('grammar');
                for (var pNum = 0; pNum < productions.length; pNum++) {
                    var words = productions[pNum].split(/\s/);
                    for (var wordNum = 2; wordNum < words.length; wordNum++) {
                        var word = words[wordNum];
                        if (firstCharIsLowerCase(word)) {
                            terminals[word] = true;
                        }
                    }
                }
                terminals['$'] = true;
                var result = Object.keys(terminals);
                gTerminals = result;

                listToInnerHTML(result, 'terminals', 'tokenText');
            }
        
            //------------------------------------------------------------------

            function isTerminal(symbol) {
                var index = gTerminals.indexOf(symbol)
                if (index != -1) {
                    return true;
                }
                if (firstCharIsLowerCase(symbol)) {
                    alert('Symbol ' + symbol + ' starts with lower-case but not a terminal!');
                }
                return false;
            }
            
            //------------------------------------------------------------------

            var gNonTerminals = [];

            function onFindNonTerminals() {
                var nonTerminals = {};
                var productions = fieldToLines('grammar');
                for (var pNum = 0; pNum < productions.length; pNum++) {
                    var words = productions[pNum].split(/\s/);
                    if (firstCharIsLowerCase(words[0])) {
                        alert('Symbol ' + words[0] + ' starts with lower-case but is on LHS of production!');
                    }
                    nonTerminals[words[0]] = true;
                }
                var result = Object.keys(nonTerminals);
                gNonTerminals = result;
                
                listToInnerHTML(result, 'nonTerminals', 'nonTermText');
            }
            
            //------------------------------------------------------------------

            function isNonTerminal(symbol) {
                var index = gNonTerminals.indexOf(symbol)
                if (index != -1) {
                    return true;
                }
                if (!firstCharIsLowerCase(symbol)) {
                    alert('Symbol ' + symbol + ' starts with upper-case but is not a non-terminal!');
                }
                return false;
            }

            //------------------------------------------------------------------

            // No gNullables since they are never used.

            function onFindNullables() {
                var nullables = {};

                var productions = fieldToLines('grammar');
                var changed = true;
                while (changed) {
                    changed = false;
                    // Keep iterating over all productions until nothing changes.
                    for (var pNum = 0; pNum < productions.length; pNum++) {
                        var production = productions[pNum];
                        var words = production.split(/\s/);
                        var LHS = words[0];
                        var RHS = words.slice(2, words.length);
                        
                        // Base case.
                        if (RHS.length == 1 && RHS[0] == 'ε') {
                            var added = addElement(nullables, LHS);
                            if (added) {
                                changed = true;
                            }
                        } else {
                            // See if all RHS terms are nullable.
                            var allNullable = true;
                            for (var wordNum = 0; wordNum < RHS.length; wordNum++) {
                                var word = RHS[wordNum];
                                var itsNullable = word in nullables;
                                if (!itsNullable) {
                                    allNullable = false;
                                    break;
                                }
                            }
                            if (allNullable) {
                                var added = addElement(nullables, LHS);
                                if (added) {
                                    changed = true;
                                }
                            }                            
                        }
                    }
                }
                var result = Object.keys(nullables);
                if (result.length == 0) {
                    result = ['&nbsp;'];
                }
                listToInnerHTML(result, 'nullables', 'nonTermText');
            }

            //------------------------------------------------------------------

            // We save this rather than parse it back out of the field.
            var gFirst = {}; // Hash of lists.
            
            // Initially, for all nonterminals A, set
            //     FIRST(A) = {t | A →tω for some ω } 
            //     
            // For all nonterminals A where A → ε is a production, 
            //     add ε to FIRST(A). 
            //     
            // Repeat the following until no changes occur:
            //     * For each production A → α, 
            //         set FIRST(A) = FIRST(A) ∪ FIRST*(α)
            
            function onFindFirst() {
                gFirst = {};        // Clear out old value.
                
                var productions = fieldToLines('grammar');

                // Start out with empty list for non=terminals.
                for (var i = 0; i < gNonTerminals.length; i++) {
                    gFirst[gNonTerminals[i]] = [];
                }

                // Initially, for all nonterminals A, set
                //     FIRST(A) = {t | A →tω for some ω } 
                for (var pNum = 0; pNum < productions.length; pNum++) {
                    var production = productions[pNum];
                    var words = production.split(/\s/);
                    var A = words[0];
                    var t = words[2];
                    
                    if (isTerminal(t)) {
                        addList(gFirst, A, t);  // Ignore return value;
                    }
                } 
                        
                // For all nonterminals A where A → ε is a production, 
                //     add ε to FIRST(A). 
                // Previous iteration took care of that already.

                // Repeat the following until no changes occur:
                //     * For each production A → α, 
                //         set FIRST(A) = FIRST(A) ∪ FIRST*(α)

                var changed = true;
                while (changed) {
                    changed = false;
                    for (var pNum = 0; pNum < productions.length; pNum++) {
                        var production = productions[pNum];
                        var words = production.split(/\s/);
                        var A = words[0];
                        var α = words.slice(2, words.length);
                        var added = addList(gFirst, A, firstStar(α));
                        if (added) {
                            changed = true;
                        }
                    }
                }

                hashOfListsToInnerHTML(gFirst, 'first');
            }
                
            //------------------------------------------------------------------

            // Define FIRST*(ω) as follows:
            //     FIRST*(ε) = { ε }
            //     FIRST*(tω) = { t }
            //     If ε ∉ FIRST(A):
            //         FIRST*(Aω) = FIRST(A) 
            //     Else (if ε ∈ FIRST(A)):
            //         FIRST*(Aω) = (FIRST(A) - { ε }) ∪ FIRST*(ω)

            function firstStar(list) {
                if (list.length == 0) {
                    return [ 'ε' ];
                }
                var firstItem = list[0];
                if (isTerminal(firstItem)) {
                    return [ firstItem ];
                }
                if (gFirst[firstItem].indexOf('ε') == -1) {
                    return gFirst[firstItem];
                } else {
                    var firstALessEpsilon = removeEpsilon(gFirst[firstItem]);
                    var rest = list.slice(1);
                    var firstStarRest = firstStar(rest);
                    var combined = firstALessEpsilon.concat(firstStarRest);
                    var result = arrayUnique(combined);
                    return result;
                }
            }
            
            //------------------------------------------------------------------

            //  Initially, for each nonterminal A, set 
            //     FOLLOW(A) = { t | B → αAtω is a production }
            //     
            // Add $ to FOLLOW(S), where S is the start symbol. 
            //     
            // Repeat the following until no changes occur:
            //     If B → αAω is a production, set
            //         FOLLOW(A) = FOLLOW(A) ∪ FIRST*(ω) - { ε }.
            //         
            //     If B → αAω is a production and ε ∈ FIRST*(ω), set 
            //         FOLLOW(A) = FOLLOW(A) ∪ FOLLOW(B).
            
            // We save this rather than parse it back out of the field.
            var gFollow = {};
            
            function onFindFollow() {
                var follow = {};   
                var productions = fieldToLines('grammar');
                var words = productions[0].split(/\s/);
                var startSymbol = words[0];     // Better be true!!
                
                // Start out with empty lists for all follows.
                for (var i = 0; i < gNonTerminals.length; i++) {
                    follow[gNonTerminals[i]] = [];
                }
                
                // Initially, for each nonterminal A, set 
                //     FOLLOW(A) = { t | B → αAtω is a production }
                for (var i = 0; i < gNonTerminals.length; i++) {
                    var A = gNonTerminals[i];
                    
                    for (var pNum = 0; pNum < productions.length; pNum++) {
                        var production = productions[pNum];
                        var words = production.split(/\s/);
                        var B = words[0];
                        var αAtω = words.slice(2, words.length);

                        var indexOfA = αAtω.indexOf(A);
                        if (indexOfA == -1 || indexOfA == αAtω.length - 1) {
                            break;  // Try next production.
                        }
                        var t = αAtω[indexOfA + 1];
                        
                        if (isTerminal(t)) {
                            addList(follow, A, [t]); // Ignore return value.
                        }
                    }                        
                }
                
                // Add $ to FOLLOW(S), where S is the start symbol.
                addList(follow, startSymbol, ['$']);    // Ignore return value.
                
                // Repeat the following until no changes occur.
                var changed = true;
                while (changed) {
                    changed = false;
                    var added = false;
                    
                    // If B → αAω is a production, set
                    //     FOLLOW(A) = FOLLOW(A) ∪ FIRST*(ω) - { ε }.
                    // Here, ω can not be empty.
                    for (var pNum = 0; pNum < productions.length; pNum++) {
                        var production = productions[pNum];
                        var words = production.split(/\s/);
                        var B = words[0];
                        var αAω = words.slice(2, words.length);

                        for (var termNum = 0; termNum < αAω.length - 1; termNum++) {
                            var A = αAω[termNum];
                            
                            if (!isNonTerminal(A)) {
                                continue;  // A is not a non-terminal.
                            }
                            var ω = αAω.slice(termNum+1);
                                    
                            var firstStarOfω = firstStar(ω);
                            var firstStarOfωLessEpsilon = removeEpsilon(firstStarOfω);            
                            added = addList(follow, A, firstStarOfωLessEpsilon);
                            if (added) {
                                changed = true;
                            }
                            
                            // If B → αAω is a production and ε ∈ FIRST*(ω), set 
                            //    FOLLOW(A) = FOLLOW(A) ∪ FOLLOW(B).
                            //  Here, ω could be empty, because definitely
                            //    ε ∈ FIRST*(ε). That's covered at *** below.
                            if (firstStar(ω).indexOf('ε') != -1) {
                                var followB = follow[B];
                                added = addList(follow, A, followB);
                                if (added) {
                                    changed = true;
                                }
                            }
                        }
                        // *** Now test where ω is empty.
                        var A = αAω[αAω.length - 1];
                        if (isNonTerminal(A)) {
                            var followB = follow[B];
                            added = addList(follow, A, followB);
                            if (added) {
                                changed = true;
                            }
                        }
                    }
                }

                // Now put hash of lists into textarea.
                
                gFollow = follow;
                hashOfListsToInnerHTML(gFollow, 'follow');                
            }
            
            //------------------------------------------------------------------
            
            function onFindNumberedGrammar() {
                var productions = fieldToLines('grammar');
                var result = [];
    
                for (var pNum = 0; pNum < productions.length; pNum++) {
                    var words = productions[pNum].split(/\s/);
                    var newLine = wrapSpan(pNum, 'ruleNumText') + '&nbsp;&nbsp;';
                    newLine += wrapSpan(words[0],'nonTermText');
                    newLine += ' ➝ ';
                    for (var wNum = 2; wNum < words.length; wNum++) {
                        if (isTerminal(words[wNum])) {
                            newLine += wrapSpan(words[wNum], 'tokenText') + ' ';
                        } else {
                            newLine += wrapSpan(words[wNum], 'nonTermText') + ' ';
                        }
                    }
                   result.push(newLine);
                }
    
                linesToInnerHTML(result, 'numberedGrammar');
            }
        
            //------------------------------------------------------------------

            function addToTable(table, nonTerm, term, pNum) {
                if (table[nonTerm][term] != '.') {
                    alert('Conflict at entry [' + nonTerm + ',' +
                        term + ']: ' + table[nonTerm][term] + ' vs. ' +
                        pNum + '.');
                } else {
                    table[nonTerm][term] = pNum;
                }
            }

            //------------------------------------------------------------------
           
            var gTable = {};

            function onFindTable() {
                var productions  = fieldToLines('grammar');
                
                // Start out with blank table.
                var table = {};
                for (var ntNum = 0; ntNum < gNonTerminals.length; ntNum++) {
                    var nt = gNonTerminals[ntNum];
                    var tableLine = {};
                    for (var tNum = 0; tNum < gTerminals.length; tNum++) {
                        var t = gTerminals[tNum];
                        tableLine[t] = '.';
                    }
                    table[nt] = tableLine;
                }
                
                for (var pNum = 0; pNum < productions.length; pNum++) {
                    var production = productions[pNum];
                    var words = production.split(/\s/);
                    var LHS = words[0];
                    var RHS = words.slice(2, words.length);
                
                    var firstStarOfRHS = firstStar(RHS);
                    for (var i = 0; i < firstStarOfRHS.length; i++) {
                        var currentTerm = firstStarOfRHS[i];
                        if (currentTerm == 'ε') {
                            continue;
                        }
                        addToTable(table, LHS, currentTerm, pNum);
                    }
                    
                    if (firstStarOfRHS.indexOf('ε') != -1) {
                        var followOfLHS = gFollow[LHS];
                        for (var i = 0; i < followOfLHS.length; i++) {
                            var currentTerm = followOfLHS[i];
                            addToTable(table, LHS, currentTerm, pNum);
                        }
                    }
                }
                
                gTable = table;
                console.log(table);
                tableToInnerHTML(table, 'table');
                //tableToInnerHTML2(table, 'table');
            }
            
            //------------------------------------------------------------------

            function onFindAll() {
                onFindTerminals();
                onFindNonTerminals();
                onFindNullables();
                onFindFirst();
                onFindFollow();
                onFindNumberedGrammar();
                onFindTable();
            }

            //==================================================================


            var gStack = [];
            var gTokenIndex = 0;
            var gTokens = '';
            
            function unwindStack() {
                var result = '';
                for (var i = gStack.length - 1; i >= 0; i--) {
                    if (i == gStack.length - 1) {
                        if (isNonTerminal(gStack[i])) {
                            result += wrapSpan(gStack[i], 'nonTermText');
                        } else {
                            result += wrapSpan(gStack[i], 'tokenText');
                        }
                    } else {
                        result += gStack[i] ;
                    }
                    result += ' ';
                }
                return result;
            }
            
            //------------------------------------------------------------------

            function updateActions(whatWeDid, token) {
                var actions = innerHTMLToLines('actions');
                var newAction = '';
                if (whatWeDid == 'accept') {
                    newAction = ' ; ' + wrapSpan('accept', 'actionText') + ' ' + wrapSpan(token, 'tokenText');
                } else {
                    newAction = ' ; ' + wrapSpan('apply', 'actionText')  + ' ' + wrapSpan(whatWeDid, 'ruleNumText');
                }
                actions[actions.length - 1] += newAction;
                if (gTokenIndex != gTokens.length) {
                    var newAction = wrapSpan(pad(gTokens[gTokenIndex],maxTermLength(), 'left'), 'tokenText') + ' ; ' + unwindStack();
                    actions.push(newAction);
                } else {
                    actions.push(pad('', maxTermLength()) + ' ;');
                }
                linesToInnerHTML(actions, 'actions');
            }
            
            //------------------------------------------------------------------

            function substitute(sententialForm, ruleNum) {
                var productions = fieldToLines('grammar');
                var production = productions[ruleNum];
                var ruleWords = production.split(/\s/);
                var LHS = ruleWords[0];
                var RHS = ruleWords.slice(2, ruleWords.length);
                if (RHS.length == 1 && RHS[0] == 'ε') {
                    RHS[0] = '';
                }
                var sentWords = sententialForm.split(/\s/);
                for (var i = 0; i < sentWords.length; i++) {
                    if (LHS == sentWords[i]) {
                        break;
                    }
                }
                var newForm = '';
                for (var j = 0; j < sentWords.length; j++) {
                    if (j == i) {
                        newForm += wrapSpan(RHS.join(' '), 'substitutionText') + ' ';
                    } else {
                        newForm += sentWords[j] + ' ';
                    }
                }
                return newForm.trim();
            }
            
            //------------------------------------------------------------------

            function updateDerivation(ruleNum) {
                var derivations = innerHTMLToLines('derivation');
                var sententialForm = derivations[derivations.length - 1];
                sententialForm = stripTags(sententialForm);
                sententialForm.trim();
                derivations[derivations.length - 1] += '&nbsp;&nbsp;<span class="ruleNumText">' + ruleNum + '➝</span>';
                var newDeriv = substitute(sententialForm, ruleNum);
                derivations.push(newDeriv);
                linesToInnerHTML(derivations, 'derivation');
            }

            //------------------------------------------------------------------
            var gStarted = false;
            var gDone = false;
            
            function onStart() {
                if (somethingIsNotSet()) {
                    alert('You have to find the terminals, FIRST, etc.');
                    return;
                }
                var source = document.getElementById('source').innerHTML;
                source = stripTags(source); // In case it's left over from partial parse.

                gTokens = source.split(/\s/);
                if (gTokens[gTokens.length - 1] != '$') {
                    gTokens.push('$');
                }
                
                var productions = fieldToLines('grammar');
                var words = productions[0].split(/\s/);
                var startSymbol = words[0];     // Better be true!!
                
                gStack = ['$', startSymbol];
                gTokenIndex = 0;
                markupWord('source', gTokens, gTokenIndex, 'tokenText');
                
                var firstAction = wrapSpan(pad(gTokens[0], maxTermLength(), 'left'), 'tokenText') + 
                    ' ; ' + wrapSpan(startSymbol, 'tokenText') + ' $';
                linesToInnerHTML([firstAction], 'actions');
                
                linesToInnerHTML([startSymbol], 'derivation');
                gStarted = true;
                gDone = false;
            }
                                            
            //------------------------------------------------------------------

            function onStep() {
                if (gDone) {
                    return;
                }
                if (somethingIsNotSet()) {
                    alert('You have to find the terminals, FIRST, etc.');
                    return;
                }
                if (!gStarted) {
                    alert('You have to click ‘Start’ before Stepping.');
                    return;
                }
                
                var stackTop = gStack.pop();
                var token = gTokens[gTokenIndex];
                if (isTerminal(stackTop)) {  
                    if (token == stackTop) {
                        gTokenIndex++;
                        markupWord('source', gTokens, gTokenIndex, 'tokenText');
                        updateActions('accept', token);
                    } else {
                        gDone = true;
                        alert ('Syntax error');
                        return;
                    }
                } else if (isNonTerminal(stackTop)) {
                    var rule = gTable[stackTop][token];
                    if (rule == '.') {
                        gDone = true;
                        alert('Synax error.');
                        return;
                    }
                    updateDerivation(rule);
                    var productions  = fieldToLines('grammar');
                    var production = productions[rule];
                    var words = production.split(/\s/);
                    var RHS = words.slice(2, words.length);
                    
                    for (var i = RHS.length - 1; i >= 0; i--) {
                        gStack.push(RHS[i]);
                    }
                    if (gStack[gStack.length - 1] == 'ε') {
                        var unused = gStack.pop();
                    }
                    updateActions(rule);
                } else {
                    gDone = true;
                    alert('Syntax error');
                    return;
                }
                if (gStack.length == 0) {
                    gDone = true;
                    alert('Successful parse.');
                }
            }
        </script>


    </body>
</html>